"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = serializeJsonApi;

var _humps = require("humps");

var _arrDiff = _interopRequireDefault(require("arr-diff"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var linkAttributes = function linkAttributes(schema) {
  return schema.properties.data.properties.attributes;
};

var requiredAttributes = function requiredAttributes(schema) {
  return linkAttributes(schema).required || [];
};

var hasKey = function hasKey(o, k) {
  return Object.prototype.hasOwnProperty.call(o, k);
};

var linkRelationships = function linkRelationships(schema) {
  return !schema || !schema.properties.data ? {} : schema.properties.data.properties.relationships;
};

var requiredRelationships = function requiredRelationships(schema) {
  return linkRelationships(schema).required || [];
};

function relationships(type, schema) {
  if (type === 'item') {
    return {
      item_type: {
        collection: false,
        type: 'item_type'
      }
    };
  }

  if (!linkRelationships(schema).properties) {
    return {};
  }

  return Object.entries(linkRelationships(schema).properties).reduce(function (acc, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        relationship = _ref2[0],
        relAttributes = _ref2[1];

    var isCollection = relAttributes.properties.data.type === 'array';
    var isObject = relAttributes.properties.data.type === 'object';
    var definition;

    if (isCollection) {
      definition = relAttributes.properties.data.items;
    } else if (isObject) {
      definition = relAttributes.properties.data;
    } else {
      definition = relAttributes.properties.data.anyOf.find(function (x) {
        return x.type[0] !== 'null';
      });
    }

    var relType = definition.properties.type.pattern.replace(new RegExp(/(^\^|\$$)/, 'g'), '');
    return Object.assign(acc, _defineProperty({}, relationship, {
      collection: isCollection,
      type: relType
    }));
  }, {});
}

function serializedRelationships(type, unserializedBody, schema) {
  return Object.entries(relationships(type, schema)).reduce(function (acc, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        relationship = _ref4[0],
        meta = _ref4[1];

    var camelizedRelationship = (0, _humps.camelize)(relationship);

    if (relationship !== camelizedRelationship && hasKey(unserializedBody, relationship) && hasKey(unserializedBody, camelizedRelationship)) {
      throw new Error("Attribute ".concat(camelizedRelationship, " is expressed both in camel-case and snake-case"));
    }

    if (hasKey(unserializedBody, camelizedRelationship) || hasKey(unserializedBody, relationship)) {
      var value = unserializedBody[camelizedRelationship] || unserializedBody[relationship];
      var data;

      if (value) {
        if (meta.collection) {
          data = value.map(function (id) {
            return {
              type: meta.type,
              id: id
            };
          });
        } else {
          data = {
            type: meta.type,
            id: value
          };
        }
      } else {
        data = null;
      }

      if (relationship !== camelizedRelationship && hasKey(unserializedBody, relationship)) {
        console.warn("Warning: Attribute ".concat(relationship, " should be expressed in camel-case syntax (").concat(camelizedRelationship, ")"));
      }

      return Object.assign(acc, _defineProperty({}, relationship, {
        data: data
      }));
    }

    if (requiredRelationships(schema).includes(relationship)) {
      throw new Error("Required attribute: ".concat(camelizedRelationship));
    }

    return Object.assign(acc, _defineProperty({}, relationship, {
      data: null
    }));
  }, {});
}

function serializedAttributes(type) {
  var unserializedBody = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var schema = arguments.length > 2 ? arguments[2] : undefined;
  var attrs = type === 'item' ? (0, _arrDiff.default)(Object.keys((0, _humps.decamelizeKeys)(unserializedBody)), ['item_type', 'id', 'created_at', 'updated_at', 'is_valid', 'published_version', 'current_version']) : Object.keys(linkAttributes(schema).properties);
  return attrs.reduce(function (acc, attr) {
    var camelizedAttr = (0, _humps.camelize)(attr);

    if (attr !== camelizedAttr && hasKey(unserializedBody, attr) && hasKey(unserializedBody, camelizedAttr)) {
      throw new Error("Attribute ".concat(camelizedAttr, " is expressed both in camel-case and snake-case"));
    }

    if (attr !== camelizedAttr && hasKey(unserializedBody, attr)) {
      console.warn("Warning: Attribute ".concat(attr, " should be expressed in camel-case syntax (").concat(camelizedAttr, ")"));
      return Object.assign(acc, _defineProperty({}, attr, unserializedBody[attr]));
    }

    if (hasKey(unserializedBody, camelizedAttr)) {
      return Object.assign(acc, _defineProperty({}, attr, unserializedBody[camelizedAttr]));
    }

    if (requiredAttributes(schema).includes(attr)) {
      throw new Error("Required attribute: ".concat(camelizedAttr));
    }

    return acc;
  }, {});
}

function serializeJsonApi() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length === 4 || args.length === 3) {
    var type = args[0],
        unserializedBody = args[1],
        link = args[2],
        itemId = args[3];
    var data = {};
    data.type = type;

    if (itemId || unserializedBody.id) {
      data.id = itemId || unserializedBody.id;
    }

    data.attributes = serializedAttributes(type, unserializedBody, link.schema);

    if (link.schema.properties && linkRelationships(link.schema)) {
      data.relationships = serializedRelationships(type, unserializedBody, link.schema);
    }

    return {
      data: data
    };
  }

  throw new Error('Invalid arguments');
}